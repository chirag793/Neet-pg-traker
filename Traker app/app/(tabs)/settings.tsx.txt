import { View, Text, StyleSheet, ScrollView, TouchableOpacity, Alert, Switch, Platform, Modal, Animated } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Stack } from 'expo-router';
import { useStudy } from '@/hooks/study-context';
import { useAuth } from '@/hooks/auth-context';
import { DataRecoveryService } from '@/utils/data-recovery';
import { DataExportService } from '@/utils/data-export';
import { Settings, Download, Upload, RefreshCw, Trash2, User, LogOut, Shield, Bell, Moon, Sun, Cloud, Smartphone, LogIn, Calendar, CalendarDays, Clock, Edit3, Check, X, Zap } from 'lucide-react-native';
import { useState, useEffect, useRef } from 'react';
import DateTimePicker from '@react-native-community/datetimepicker';
import { trpc } from '@/lib/trpc';

const formatDate = (dateString: string): string => {
  try {
    const date = new Date(dateString);
    const day = date.getDate();
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const month = monthNames[date.getMonth()];
    const year = date.getFullYear();
    return `${day} ${month} ${year}`;
  } catch (error) {
    return 'Invalid date';
  }
};

function BackendTestComponent() {
  const [testName, setTestName] = useState<string>('');
  const [response, setResponse] = useState<string>('');
  
  const hiMutation = trpc.example.hi.useMutation({
    onSuccess: (data) => {
      setResponse(`Backend says: ${data.hello} at ${new Date(data.date).toLocaleTimeString()}`);
    },
    onError: (error) => {
      setResponse(`Error: ${error.message}`);
    }
  });
  
  const testBackend = () => {
    if (!testName.trim()) {
      setResponse('Please enter a name first');
      return;
    }
    hiMutation.mutate({ name: testName });
  };
  
  return (
    <View style={styles.backendTestContainer}>
      <View style={styles.settingItem}>
        <View style={styles.settingLeft}>
          <Zap size={20} color="#007AFF" />
          <Text style={styles.settingText}>Test tRPC Connection</Text>
        </View>
        <TouchableOpacity 
          style={styles.testButton} 
          onPress={testBackend}
          disabled={hiMutation.isPending}
        >
          <Text style={styles.testButtonText}>
            {hiMutation.isPending ? 'Testing...' : 'Test'}
          </Text>
        </TouchableOpacity>
      </View>
      
      <View style={styles.testInputContainer}>
        <Text style={styles.testInputLabel}>Enter your name:</Text>
        <View style={styles.testInputWrapper}>
          <Text 
            style={styles.testInput}
            onPress={() => {
              Alert.prompt(
                'Enter Name',
                'Enter a name to test the backend:',
                (text) => setTestName(text || ''),
                'plain-text',
                testName
              );
            }}
          >
            {testName || 'Tap to enter name'}
          </Text>
        </View>
      </View>
      
      {response ? (
        <View style={styles.testResponse}>
          <Text style={styles.testResponseText}>{response}</Text>
        </View>
      ) : null}
    </View>
  );
}

export default function SettingsScreen() {
  const { 
    clearAllData, 
    refreshData, 
    studySessions, 
    testScores, 
    subjects, 
    studyPlans, 
    examDates, 
    currentUser,
    syncWithCloud,
    backupToiCloud,
    restoreFromiCloud,
    forceRestoreFromiCloud,
    emergencyDataRecovery,
    updateExamDates 
  } = useStudy();
  const { user, signOut, signInLocally, signInWithApple, isLoading: authLoading, isAppleSignInAvailable, isLocalUser } = useAuth();

  const [isDarkMode, setIsDarkMode] = useState(false);
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [isExporting, setIsExporting] = useState(false);
  const [isRecovering, setIsRecovering] = useState(false);
  const [isImporting, setIsImporting] = useState(false);
  const [iCloudStatus, setICloudStatus] = useState<'checking' | 'available' | 'unavailable' | 'synced'>('checking');
  const [lastBackupTime, setLastBackupTime] = useState<string | null>(null);
  const [showNEETPGPicker, setShowNEETPGPicker] = useState(false);
  const [showINICETPicker, setShowINICETPicker] = useState(false);
  const [tempNEETDate, setTempNEETDate] = useState<Date | null>(null);
  const [tempINICETDate, setTempINICETDate] = useState<Date | null>(null);
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    // Load theme preference and check iCloud status
    checkiCloudStatus();
  }, [currentUser]);

  const checkiCloudStatus = async () => {
    if (Platform.OS !== 'ios') {
      setICloudStatus('unavailable');
      return;
    }

    try {
      // iCloud is available on iOS, but we need a user to check for existing data
      if (currentUser?.id) {
        // Try to read from iCloud to check if there's existing data
        const testData = await restoreFromiCloud(`${currentUser.id}_sessions`);
        if (testData) {
          setICloudStatus('synced');
          setLastBackupTime(new Date().toISOString());
        } else {
          setICloudStatus('available');
        }
      } else {
        // iCloud is available but no user is logged in
        setICloudStatus('available');
      }
    } catch (error) {
      console.warn('iCloud check failed:', error);
      setICloudStatus('unavailable');
    }
  };

  const handleRecoverData = async () => {
    try {
      setIsRecovering(true);
      
      // First try to recover from iCloud on iOS if user is logged in
      if (Platform.OS === 'ios' && currentUser?.id) {
        try {
          console.log('Checking iCloud for data...');
          const iCloudSessions = await restoreFromiCloud(`${currentUser.id}_sessions`);
          const iCloudScores = await restoreFromiCloud(`${currentUser.id}_scores`);
          const iCloudSubjects = await restoreFromiCloud(`${currentUser.id}_subjects`);
          const iCloudPlans = await restoreFromiCloud(`${currentUser.id}_plans`);
          const iCloudDates = await restoreFromiCloud(`${currentUser.id}_dates`);
          
          const hasICloudData = iCloudSessions || iCloudScores || iCloudSubjects || iCloudPlans || iCloudDates;
          
          if (hasICloudData) {
            let iCloudMessage = 'Found data in iCloud backup:\n\n';
            if (iCloudSessions?.length) iCloudMessage += `• ${iCloudSessions.length} study sessions\n`;
            if (iCloudScores?.length) iCloudMessage += `• ${iCloudScores.length} test scores\n`;
            if (iCloudSubjects?.length) iCloudMessage += `• ${iCloudSubjects.length} subjects\n`;
            if (iCloudPlans?.length) iCloudMessage += `• ${iCloudPlans.length} study plans\n`;
            if (iCloudDates) iCloudMessage += `• Exam dates\n`;
            
            iCloudMessage += '\nChoose recovery method:';
            
            Alert.alert(
              'iCloud Backup Found',
              iCloudMessage,
              [
                { text: 'Cancel', style: 'cancel' },
                {
                  text: 'Restore from iCloud',
                  onPress: async () => {
                    try {
                      const restored = await forceRestoreFromiCloud();
                      if (restored) {
                        Alert.alert('Success', 'Data restored from iCloud Keychain backup!');
                      } else {
                        Alert.alert('No Data', 'No data found in iCloud Keychain. Try local recovery.');
                      }
                    } catch (error) {
                      console.error('iCloud restore error:', error);
                      Alert.alert('Error', 'Failed to restore from iCloud. Please try local recovery.');
                    }
                  }
                },
                {
                  text: 'Try Local Storage',
                  onPress: () => performLocalRecovery()
                }
              ]
            );
            return;
          } else {
            console.log('No iCloud data found for current user, proceeding with local recovery');
          }
        } catch (error) {
          console.warn('iCloud recovery check failed, trying local recovery:', error);
        }
      } else if (Platform.OS === 'ios' && !currentUser?.id) {
        Alert.alert(
          'Sign In Required',
          'To restore data from iCloud, please sign in with your Apple ID or Google account first.',
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Try Local Recovery', onPress: () => performLocalRecovery() }
          ]
        );
        return;
      }
      
      // Fallback to local recovery
      await performLocalRecovery();
    } catch (error) {
      console.error('Recovery error:', error);
      Alert.alert(
        'Recovery Error', 
        `An error occurred during data recovery:\n\n${error}\n\nPlease check your device storage and try again.`
      );
    } finally {
      setIsRecovering(false);
    }
  };

  const performLocalRecovery = async () => {
    const result = await DataRecoveryService.recoverAllData(currentUser?.id);
    
    console.log('Local recovery result:', result);
    
    if (result.success) {
      const totalItems = result.recoveredData.sessions.length + 
                        result.recoveredData.scores.length + 
                        result.recoveredData.subjects.length + 
                        result.recoveredData.plans.length;
      
      const hasExamDates = result.recoveredData.examDates.NEET_PG || result.recoveredData.examDates.INICET;
      
      if (totalItems > 0 || hasExamDates) {
        let message = 'Found recoverable data:\n\n';
        
        if (result.recoveredData.sessions.length > 0) {
          message += `• ${result.recoveredData.sessions.length} study sessions\n`;
        }
        if (result.recoveredData.scores.length > 0) {
          message += `• ${result.recoveredData.scores.length} test scores\n`;
        }
        if (result.recoveredData.subjects.length > 0) {
          message += `• ${result.recoveredData.subjects.length} subjects\n`;
        }
        if (result.recoveredData.plans.length > 0) {
          message += `• ${result.recoveredData.plans.length} study plans\n`;
        }
        if (hasExamDates) {
          message += `• Exam dates\n`;
        }
        
        if (result.errors.length > 0) {
          message += `\n⚠️ ${result.errors.length} recovery warnings (check console for details)`;
        }
        
        message += '\n\nThis will merge with your existing data. Continue?';
        
        Alert.alert(
          'Data Recovery Successful',
          message,
          [
            { text: 'Cancel', style: 'cancel' },
            {
              text: 'Restore Data',
              onPress: async () => {
                try {
                  await DataRecoveryService.saveRecoveredData(result.recoveredData, currentUser?.id);
                  await refreshData();
                  Alert.alert('Success', `Data restored successfully!\n\nRecovered ${totalItems} items${hasExamDates ? ' + exam dates' : ''}.`);
                } catch (error) {
                  console.error('Error saving recovered data:', error);
                  Alert.alert('Error', 'Failed to save recovered data. Please try again.');
                }
              }
            }
          ]
        );
      } else {
        Alert.alert(
          'No Data Found', 
          result.errors.length > 0 
            ? `No recoverable data found.\n\nIssues encountered:\n${result.errors.slice(0, 3).join('\n')}${result.errors.length > 3 ? '\n...' : ''}` 
            : 'No recoverable data was found in local storage.'
        );
      }
    } else {
      const errorMessage = result.errors.length > 0 
        ? `Recovery failed:\n\n${result.errors.slice(0, 2).join('\n')}${result.errors.length > 2 ? '\n...' : ''}` 
        : 'Failed to recover data. Please try again.';
      
      Alert.alert('Recovery Failed', errorMessage);
    }
  };

  const handleExportData = async () => {
    try {
      setIsExporting(true);
      
      // Show export options
      Alert.alert(
        'Export Data',
        Platform.OS === 'ios' 
          ? 'Choose export method:\n\n• Share File: Create a backup file to save anywhere\n• iCloud Backup: Automatic backup to your iCloud account'
          : 'Export your study data to a backup file',
        Platform.OS === 'ios' ? [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'iCloud Backup',
            onPress: async () => {
              if (currentUser?.id) {
                try {
                  await backupToiCloud(studySessions, `${currentUser.id}_sessions`);
                  await backupToiCloud(testScores, `${currentUser.id}_scores`);
                  await backupToiCloud(subjects, `${currentUser.id}_subjects`);
                  await backupToiCloud(studyPlans, `${currentUser.id}_plans`);
                  await backupToiCloud(examDates, `${currentUser.id}_dates`);
                  setLastBackupTime(new Date().toISOString());
                  setICloudStatus('synced');
                  Alert.alert('Success', 'Data backed up to iCloud!');
                } catch (error) {
                  console.error('iCloud backup error:', error);
                  Alert.alert('Error', 'Failed to backup to iCloud. Please try again.');
                }
              } else {
                Alert.alert('Sign In Required', 'Please sign in with Apple ID or Google to use iCloud backup.');
              }
            }
          },
          {
            text: 'Share File',
            onPress: async () => {
              const success = await DataExportService.exportAllData(
                studySessions,
                testScores,
                subjects,
                studyPlans,
                examDates,
                currentUser?.id,
                currentUser?.email
              );
              
              if (success) {
                Alert.alert('Success', 'Data exported successfully! Save to Files app for iCloud sync.');
              }
            }
          }
        ] : [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'Export',
            onPress: async () => {
              const success = await DataExportService.exportAllData(
                studySessions,
                testScores,
                subjects,
                studyPlans,
                examDates,
                currentUser?.id,
                currentUser?.email
              );
              
              if (success) {
                Alert.alert('Success', 'Data exported successfully!');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Export error:', error);
      Alert.alert('Error', 'Failed to export data.');
    } finally {
      setIsExporting(false);
    }
  };

  const handleImportData = async () => {
    try {
      setIsImporting(true);
      const importedData = await DataExportService.importData();
      
      if (importedData) {
        Alert.alert(
          'Import Data',
          `This backup contains:\n• ${importedData.data.studySessions.length} study sessions\n• ${importedData.data.testScores.length} test scores\n• ${importedData.data.subjects.length} subjects\n\nThis will merge with your existing data. Continue?`,
          [
            { text: 'Cancel', style: 'cancel' },
            {
              text: 'Import',
              onPress: async () => {
                await DataExportService.saveImportedData(importedData, currentUser?.id);
                await refreshData();
                Alert.alert('Success', 'Data imported successfully!');
              }
            }
          ]
        );
      }
    } catch (error) {
      console.error('Import error:', error);
      Alert.alert('Error', 'Failed to import data.');
    } finally {
      setIsImporting(false);
    }
  };

  const handleClearAllData = () => {
    Alert.alert(
      'Clear All Data',
      'Are you sure you want to clear all data? This action cannot be undone.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Clear',
          style: 'destructive',
          onPress: async () => {
            await clearAllData();
            Alert.alert('Success', 'All data has been cleared.');
          }
        }
      ]
    );
  };

  const showiCloudInfo = () => {
    Alert.alert(
      'iCloud Backup Guide',
      'Your study data is automatically backed up to iCloud when you:\n\n' +
      '✅ Sign in with Apple ID\n' +
      '✅ Complete study sessions\n' +
      '✅ Add test scores\n' +
      '✅ Export data to Files app\n\n' +
      'To find your backups:\n' +
      '• Files app → iCloud Drive\n' +
      '• Settings → [Your Name] → iCloud\n' +
      '• This app automatically syncs across your Apple devices\n\n' +
      'Your data is encrypted and private to your Apple ID.',
      [{ text: 'Got it!' }]
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <Stack.Screen options={{ title: 'Settings' }} />
      
      <ScrollView style={styles.scrollView}>
        {/* Account Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Account</Text>
          {user ? (
            <View style={styles.accountCard}>
              <View style={styles.accountInfo}>
                <User size={24} color="#007AFF" />
                <View style={styles.accountDetails}>
                  <Text style={styles.accountName}>{user.name}</Text>
                  <Text style={styles.accountEmail}>{user.email}</Text>
                  {isLocalUser && (
                    <Text style={styles.accountLocalBadge}>📱 Local Storage</Text>
                  )}
                </View>
              </View>
              <TouchableOpacity style={styles.signOutButton} onPress={signOut}>
                <LogOut size={16} color="#FF3B30" />
                <Text style={styles.signOutText}>Sign Out</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <View style={styles.loginSection}>
              <View style={styles.loginPrompt}>
                <LogIn size={24} color="#8E8E93" />
                <Text style={styles.loginPromptText}>
                  {Platform.OS === 'ios' ? 'Sign in to sync data or save locally' : 'Save your data locally on this device'}
                </Text>
              </View>
              
              <TouchableOpacity 
                style={styles.localSignInButton} 
                onPress={async () => {
                  const result = await signInLocally();
                  if (result && result.type === 'success') {
                    Alert.alert('Success', 'Local storage enabled. Your data will be saved on this device.');
                  }
                }}
                disabled={authLoading}
              >
                <Smartphone size={20} color="#FFFFFF" />
                <Text style={styles.localSignInText}>
                  {authLoading ? 'Setting up...' : 'Use Local Storage'}
                </Text>
              </TouchableOpacity>
              
              {Platform.OS === 'ios' && isAppleSignInAvailable && (
                <TouchableOpacity 
                  style={styles.appleSignInButton} 
                  onPress={signInWithApple}
                  disabled={authLoading}
                >
                  <Text style={styles.appleSignInText}>
                    {authLoading ? 'Signing in...' : 'Sign in with Apple'}
                  </Text>
                </TouchableOpacity>
              )}
            </View>
          )}
        </View>

        {/* Data Management Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            Data Management {Platform.OS === 'ios' && '(iCloud Enabled)'}
          </Text>
          
          {Platform.OS === 'ios' && (
            <View style={styles.iCloudStatus}>
              <View style={styles.settingLeft}>
                <Cloud size={16} color={iCloudStatus === 'synced' ? '#34C759' : iCloudStatus === 'available' ? '#007AFF' : '#FF3B30'} />
                <Text style={styles.iCloudStatusText}>
                  iCloud Status: {iCloudStatus === 'synced' ? 'Synced' : iCloudStatus === 'available' ? (currentUser ? 'Available' : 'Available (Sign in to use)') : iCloudStatus === 'checking' ? 'Checking...' : 'Unavailable'}
                </Text>
              </View>
              {lastBackupTime && (
                <Text style={styles.lastBackupText}>
                  Last backup: {formatDate(lastBackupTime.split('T')[0])}
                </Text>
              )}
            </View>
          )}

          <TouchableOpacity style={styles.settingItem} onPress={handleExportData} disabled={isExporting}>
            <View style={styles.settingLeft}>
              {Platform.OS === 'ios' ? <Cloud size={20} color="#007AFF" /> : <Upload size={20} color="#007AFF" />}
              <Text style={styles.settingText}>
                {Platform.OS === 'ios' ? 'Backup Data' : 'Export Data'}
              </Text>
            </View>
            <Text style={styles.settingValue}>
              {isExporting ? 'Processing...' : Platform.OS === 'ios' ? 'iCloud & File' : 'Backup'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.settingItem} onPress={handleRecoverData} disabled={isRecovering}>
            <View style={styles.settingLeft}>
              {Platform.OS === 'ios' ? <Cloud size={20} color="#007AFF" /> : <Download size={20} color="#007AFF" />}
              <Text style={styles.settingText}>
                {Platform.OS === 'ios' ? 'Restore Data' : 'Recover Data'}
              </Text>
            </View>
            <Text style={styles.settingValue}>
              {isRecovering ? 'Restoring...' : Platform.OS === 'ios' ? 'iCloud & Local' : 'Restore'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[styles.settingItem, { backgroundColor: '#FFF3CD', borderColor: '#FFC107', borderWidth: 1 }]} 
            onPress={async () => {
              Alert.alert(
                '🚨 Emergency Data Recovery',
                'This will scan all storage locations for your data and attempt to recover it. Use this if your data disappeared after an update.\n\nThis is safe and will not delete existing data.',
                [
                  { text: 'Cancel', style: 'cancel' },
                  {
                    text: 'Start Recovery',
                    onPress: async () => {
                      try {
                        setIsRecovering(true);
                        const result = await emergencyDataRecovery();
                        
                        if (result.success) {
                          Alert.alert('✅ Recovery Successful!', result.message);
                          await refreshData();
                        } else {
                          Alert.alert('❌ No Data Found', result.message);
                        }
                      } catch (error) {
                        Alert.alert('❌ Recovery Failed', `Error: ${error}`);
                      } finally {
                        setIsRecovering(false);
                      }
                    }
                  }
                ]
              );
            }} 
            disabled={isRecovering}
          >
            <View style={styles.settingLeft}>
              <RefreshCw size={20} color="#FF8C00" />
              <Text style={[styles.settingText, { color: '#FF8C00', fontWeight: '600' }]}>Emergency Recovery</Text>
            </View>
            <Text style={[styles.settingValue, { color: '#FF8C00' }]}>
              {isRecovering ? 'Scanning...' : 'Lost Data?'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.settingItem} onPress={handleImportData} disabled={isImporting}>
            <View style={styles.settingLeft}>
              <Download size={20} color="#007AFF" />
              <Text style={styles.settingText}>Import Data</Text>
            </View>
            <Text style={styles.settingValue}>{isImporting ? 'Importing...' : 'Restore'}</Text>
          </TouchableOpacity>
          
          {Platform.OS === 'ios' && (
            <TouchableOpacity style={styles.settingItem} onPress={showiCloudInfo}>
              <View style={styles.settingLeft}>
                <Cloud size={20} color="#007AFF" />
                <Text style={styles.settingText}>iCloud Backup Guide</Text>
              </View>
              <Text style={styles.settingValue}>Info</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* Exam Dates - Redesigned */}
        <View style={styles.examDatesContainer}>
          <View style={styles.examHeaderRow}>
            <CalendarDays size={20} color="#FF6B35" />
            <Text style={styles.examMainTitle}>EXAM DATES</Text>
          </View>
          
          <View style={styles.examCardsContainer}>
            {/* NEET PG Card */}
            <TouchableOpacity 
              style={[
                styles.examCard,
                examDates.NEET_PG ? styles.examCardSet : styles.examCardUnset
              ]} 
              onPress={() => {
                setTempNEETDate(examDates.NEET_PG ? new Date(examDates.NEET_PG) : new Date());
                setShowNEETPGPicker(true);
                Animated.timing(fadeAnim, {
                  toValue: 1,
                  duration: 300,
                  useNativeDriver: true,
                }).start();
              }}
              activeOpacity={0.8}
            >
              <View style={styles.examCardHeader}>
                <View style={styles.examBadge}>
                  <Text style={styles.examBadgeText}>NEET PG</Text>
                </View>
                <Edit3 size={14} color={examDates.NEET_PG ? "#007AFF" : "#FF6B35"} />
              </View>
              
              {examDates.NEET_PG ? (
                <>
                  <Text style={styles.examDateDisplay}>{formatDate(examDates.NEET_PG)}</Text>
                  <View style={styles.examCountdown}>
                    <Clock size={12} color="#666" />
                    <Text style={styles.examCountdownText}>
                      {Math.ceil((new Date(examDates.NEET_PG).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))} days
                    </Text>
                  </View>
                </>
              ) : (
                <View style={styles.examUnsetContent}>
                  <Calendar size={24} color="#FFB74D" />
                  <Text style={styles.examUnsetText}>Set date</Text>
                </View>
              )}
            </TouchableOpacity>

            {/* INICET Card */}
            <TouchableOpacity 
              style={[
                styles.examCard,
                examDates.INICET ? styles.examCardSet : styles.examCardUnset
              ]} 
              onPress={() => {
                setTempINICETDate(examDates.INICET ? new Date(examDates.INICET) : new Date());
                setShowINICETPicker(true);
                Animated.timing(fadeAnim, {
                  toValue: 1,
                  duration: 300,
                  useNativeDriver: true,
                }).start();
              }}
              activeOpacity={0.8}
            >
              <View style={styles.examCardHeader}>
                <View style={[styles.examBadge, { backgroundColor: '#E8F5E9' }]}>
                  <Text style={[styles.examBadgeText, { color: '#2E7D32' }]}>INICET</Text>
                </View>
                <Edit3 size={14} color={examDates.INICET ? "#007AFF" : "#FF6B35"} />
              </View>
              
              {examDates.INICET ? (
                <>
                  <Text style={styles.examDateDisplay}>{formatDate(examDates.INICET)}</Text>
                  <View style={styles.examCountdown}>
                    <Clock size={12} color="#666" />
                    <Text style={styles.examCountdownText}>
                      {Math.ceil((new Date(examDates.INICET).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))} days
                    </Text>
                  </View>
                </>
              ) : (
                <View style={styles.examUnsetContent}>
                  <Calendar size={24} color="#66BB6A" />
                  <Text style={styles.examUnsetText}>Set date</Text>
                </View>
              )}
            </TouchableOpacity>
          </View>
        </View>

        {/* NEET PG Date Picker Modal */}
        <Modal
          visible={showNEETPGPicker}
          transparent={true}
          animationType="slide"
          onRequestClose={() => {
            setShowNEETPGPicker(false);
            setTempNEETDate(null);
          }}
        >
          <TouchableOpacity 
            style={styles.modalOverlay} 
            activeOpacity={1}
            onPress={() => {
              setShowNEETPGPicker(false);
              setTempNEETDate(null);
            }}
          >
            <Animated.View 
              style={[
                styles.modalContent,
                { opacity: fadeAnim }
              ]}
            >
              <TouchableOpacity 
                activeOpacity={1}
                onPress={(e) => e.stopPropagation()}
              >
                <View style={styles.modalHeader}>
                  <Text style={styles.modalTitle}>Select NEET PG Date</Text>
                  <TouchableOpacity 
                    style={styles.modalCloseButton}
                    onPress={() => {
                      setShowNEETPGPicker(false);
                      setTempNEETDate(null);
                    }}
                  >
                    <X size={24} color="#666" />
                  </TouchableOpacity>
                </View>
                
                <View style={styles.datePickerWrapper}>
                  <DateTimePicker
                    value={tempNEETDate || new Date()}
                    mode="date"
                    display={Platform.OS === 'ios' ? 'spinner' : 'default'}
                    style={styles.modernDatePicker}
                    textColor="#000000"
                    onChange={(event, selectedDate) => {
                      if (Platform.OS === 'android') {
                        setShowNEETPGPicker(false);
                        if (selectedDate) {
                          updateExamDates({
                            ...examDates,
                            NEET_PG: selectedDate.toISOString().split('T')[0]
                          });
                        }
                        setTempNEETDate(null);
                      } else if (selectedDate) {
                        setTempNEETDate(selectedDate);
                      }
                    }}
                  />
                </View>
                
                {Platform.OS === 'ios' && (
                  <View style={styles.modalActions}>
                    <TouchableOpacity 
                      style={styles.modalCancelButton}
                      onPress={() => {
                        setShowNEETPGPicker(false);
                        setTempNEETDate(null);
                      }}
                    >
                      <Text style={styles.modalCancelText}>Cancel</Text>
                    </TouchableOpacity>
                    
                    <TouchableOpacity 
                      style={styles.modalConfirmButton}
                      onPress={() => {
                        if (tempNEETDate) {
                          updateExamDates({
                            ...examDates,
                            NEET_PG: tempNEETDate.toISOString().split('T')[0]
                          });
                        }
                        setShowNEETPGPicker(false);
                        setTempNEETDate(null);
                      }}
                    >
                      <Check size={20} color="#FFF" />
                      <Text style={styles.modalConfirmText}>Set Date</Text>
                    </TouchableOpacity>
                  </View>
                )}
              </TouchableOpacity>
            </Animated.View>
          </TouchableOpacity>
        </Modal>

        {/* INICET Date Picker Modal */}
        <Modal
          visible={showINICETPicker}
          transparent={true}
          animationType="slide"
          onRequestClose={() => {
            setShowINICETPicker(false);
            setTempINICETDate(null);
          }}
        >
          <TouchableOpacity 
            style={styles.modalOverlay} 
            activeOpacity={1}
            onPress={() => {
              setShowINICETPicker(false);
              setTempINICETDate(null);
            }}
          >
            <Animated.View 
              style={[
                styles.modalContent,
                { opacity: fadeAnim }
              ]}
            >
              <TouchableOpacity 
                activeOpacity={1}
                onPress={(e) => e.stopPropagation()}
              >
                <View style={styles.modalHeader}>
                  <Text style={styles.modalTitle}>Select INICET Date</Text>
                  <TouchableOpacity 
                    style={styles.modalCloseButton}
                    onPress={() => {
                      setShowINICETPicker(false);
                      setTempINICETDate(null);
                    }}
                  >
                    <X size={24} color="#666" />
                  </TouchableOpacity>
                </View>
                
                <View style={styles.datePickerWrapper}>
                  <DateTimePicker
                    value={tempINICETDate || new Date()}
                    mode="date"
                    display={Platform.OS === 'ios' ? 'spinner' : 'default'}
                    style={styles.modernDatePicker}
                    textColor="#000000"
                    onChange={(event, selectedDate) => {
                      if (Platform.OS === 'android') {
                        setShowINICETPicker(false);
                        if (selectedDate) {
                          updateExamDates({
                            ...examDates,
                            INICET: selectedDate.toISOString().split('T')[0]
                          });
                        }
                        setTempINICETDate(null);
                      } else if (selectedDate) {
                        setTempINICETDate(selectedDate);
                      }
                    }}
                  />
                </View>
                
                {Platform.OS === 'ios' && (
                  <View style={styles.modalActions}>
                    <TouchableOpacity 
                      style={styles.modalCancelButton}
                      onPress={() => {
                        setShowINICETPicker(false);
                        setTempINICETDate(null);
                      }}
                    >
                      <Text style={styles.modalCancelText}>Cancel</Text>
                    </TouchableOpacity>
                    
                    <TouchableOpacity 
                      style={[styles.modalConfirmButton, { backgroundColor: '#2E7D32' }]}
                      onPress={() => {
                        if (tempINICETDate) {
                          updateExamDates({
                            ...examDates,
                            INICET: tempINICETDate.toISOString().split('T')[0]
                          });
                        }
                        setShowINICETPicker(false);
                        setTempINICETDate(null);
                      }}
                    >
                      <Check size={20} color="#FFF" />
                      <Text style={styles.modalConfirmText}>Set Date</Text>
                    </TouchableOpacity>
                  </View>
                )}
              </TouchableOpacity>
            </Animated.View>
          </TouchableOpacity>
        </Modal>

        {/* App Preferences */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Preferences</Text>
          
          <View style={styles.settingItem}>
            <View style={styles.settingLeft}>
              <Bell size={20} color="#007AFF" />
              <Text style={styles.settingText}>Notifications</Text>
            </View>
            <Switch
              value={notificationsEnabled}
              onValueChange={setNotificationsEnabled}
              trackColor={{ false: '#E5E5EA', true: '#34C759' }}
              thumbColor="#FFFFFF"
            />
          </View>

          <View style={styles.settingItem}>
            <View style={styles.settingLeft}>
              {isDarkMode ? <Moon size={20} color="#007AFF" /> : <Sun size={20} color="#007AFF" />}
              <Text style={styles.settingText}>Dark Mode</Text>
            </View>
            <Switch
              value={isDarkMode}
              onValueChange={setIsDarkMode}
              trackColor={{ false: '#E5E5EA', true: '#34C759' }}
              thumbColor="#FFFFFF"
            />
          </View>
        </View>

        {/* Danger Zone */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Danger Zone</Text>
          
          <TouchableOpacity style={styles.dangerItem} onPress={handleClearAllData}>
            <View style={styles.settingLeft}>
              <Trash2 size={20} color="#FF3B30" />
              <Text style={[styles.settingText, { color: '#FF3B30' }]}>Clear All Data</Text>
            </View>
          </TouchableOpacity>
        </View>

        {/* Backend Test Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Backend Test</Text>
          <BackendTestComponent />
        </View>

        {/* App Info */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>About</Text>
          
          <View style={styles.settingItem}>
            <View style={styles.settingLeft}>
              <Smartphone size={20} color="#8E8E93" />
              <Text style={styles.settingText}>Version</Text>
            </View>
            <Text style={styles.settingValue}>1.0.0</Text>
          </View>

          <View style={styles.settingItem}>
            <View style={styles.settingLeft}>
              <Shield size={20} color="#8E8E93" />
              <Text style={styles.settingText}>Platform</Text>
            </View>
            <Text style={styles.settingValue}>{Platform.OS === 'ios' ? 'iOS' : 'Android'}</Text>
          </View>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F2F2F7',
  },
  scrollView: {
    flex: 1,
  },
  section: {
    marginTop: 32,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 22,
    fontWeight: '600',
    color: '#1C1C1E',
    marginBottom: 8,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  accountCard: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 8,
  },
  accountInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  accountDetails: {
    marginLeft: 12,
    flex: 1,
  },
  accountName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1C1C1E',
  },
  accountEmail: {
    fontSize: 14,
    color: '#8E8E93',
    marginTop: 2,
  },
  accountLocalBadge: {
    fontSize: 12,
    color: '#4F46E5',
    marginTop: 4,
    fontWeight: '600',
  },
  signOutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FFE5E5',
    borderRadius: 8,
    padding: 12,
    gap: 8,
  },
  signOutText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FF3B30',
  },
  iCloudStatus: {
    backgroundColor: '#F2F2F7',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  iCloudStatusText: {
    fontSize: 14,
    color: '#1C1C1E',
    marginLeft: 8,
  },
  lastBackupText: {
    fontSize: 12,
    color: '#8E8E93',
    marginTop: 4,
    marginLeft: 24,
  },
  settingItem: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  settingLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  settingText: {
    fontSize: 16,
    color: '#1C1C1E',
    marginLeft: 12,
  },
  settingValue: {
    fontSize: 14,
    color: '#8E8E93',
  },
  dangerItem: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 8,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#FF3B30',
  },
  loginSection: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 20,
    marginBottom: 8,
  },
  loginPrompt: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
  },
  loginPromptText: {
    fontSize: 16,
    color: '#8E8E93',
    marginLeft: 12,
    flex: 1,
  },
  appleSignInButton: {
    backgroundColor: '#000000',
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    marginBottom: 12,
  },
  appleSignInText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  localSignInButton: {
    backgroundColor: '#4F46E5',
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 8,
    marginBottom: 12,
  },
  localSignInText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  examDatesContainer: {
    marginTop: 24,
    marginHorizontal: 16,
    marginBottom: 8,
  },
  examHeaderRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    gap: 8,
  },
  examMainTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1C1C1E',
    letterSpacing: 0.5,
  },
  examCardsContainer: {
    flexDirection: 'row',
    gap: 12,
  },
  examCard: {
    flex: 1,
    borderRadius: 12,
    padding: 14,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 3,
  },
  examCardSet: {
    backgroundColor: '#FFFFFF',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  examCardUnset: {
    backgroundColor: '#FFF8F3',
    borderWidth: 2,
    borderColor: '#FFB74D',
    borderStyle: 'dashed' as const,
  },
  examCardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  examBadge: {
    backgroundColor: '#FFEBE5',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  examBadgeText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#FF6B35',
    letterSpacing: 0.3,
  },
  examDateDisplay: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1C1C1E',
    marginBottom: 6,
  },
  examCountdown: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  examCountdownText: {
    fontSize: 12,
    color: '#666',
    fontWeight: '500',
  },
  examUnsetContent: {
    alignItems: 'center',
    paddingVertical: 8,
    gap: 6,
  },
  examUnsetText: {
    fontSize: 13,
    color: '#999',
    fontWeight: '500',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#FFFFFF',
    borderRadius: 24,
    width: '90%',
    maxWidth: 400,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
    elevation: 10,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 24,
    paddingTop: 24,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1C1C1E',
  },
  modalCloseButton: {
    padding: 4,
  },
  datePickerWrapper: {
    paddingVertical: 20,
    backgroundColor: '#FAFAFA',
  },
  modernDatePicker: {
    backgroundColor: 'transparent',
    height: 200,
  },
  modalActions: {
    flexDirection: 'row',
    paddingHorizontal: 24,
    paddingVertical: 20,
    gap: 12,
    borderTopWidth: 1,
    borderTopColor: '#F0F0F0',
  },
  modalCancelButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#F5F5F5',
    alignItems: 'center',
  },
  modalCancelText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#666',
  },
  modalConfirmButton: {
    flex: 1,
    flexDirection: 'row',
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#FF6B35',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
  },
  modalConfirmText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  backendTestContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 8,
  },
  testButton: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
  },
  testButtonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '600',
  },
  testInputContainer: {
    marginTop: 12,
  },
  testInputLabel: {
    fontSize: 14,
    color: '#8E8E93',
    marginBottom: 8,
  },
  testInputWrapper: {
    borderWidth: 1,
    borderColor: '#E5E5EA',
    borderRadius: 8,
    backgroundColor: '#F9F9F9',
  },
  testInput: {
    padding: 12,
    fontSize: 16,
    color: '#1C1C1E',
    minHeight: 44,
  },
  testResponse: {
    marginTop: 12,
    padding: 12,
    backgroundColor: '#F0F9FF',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#B3E5FC',
  },
  testResponseText: {
    fontSize: 14,
    color: '#0277BD',
    fontWeight: '500',
  },
});